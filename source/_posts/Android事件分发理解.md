title: "Android事件分发理解"             #可以随意修改,可以是中文
date: 2017-08-22 17:30:23        #创建的时间,一般不改
categories: blog                 #文章文类
tags: [事件分发,Android]                 #文章tag标签,多个标签用逗号隔开
---

## Android事件分发理解

> 相信大家在工作或者面试的过程中，都会遇到一个很常见的问题，Android事件分发机制。这篇文章结合自己的理解来对事件分发机制探讨一下.
>
> ### View
>
> 首先我们看下View的的 dispatchTouchEvent方法
>
> ```Java
> public boolean dispatchTouchEvent(MotionEvent event) {  
>     if (mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED &&  
>             mOnTouchListener.onTouch(this, event)) {  
>         return true;  
>     }  
>     return onTouchEvent(event);  
> }
> ```
>
> 这个方法非常的简洁，只有短短几行代码！我们可以看到，在这个方法内，首先是进行了一个判断，如果mOnTouchListener != null，(mViewFlags & ENABLED_MASK) == ENABLED和mOnTouchListener.onTouch(this, event)这三个条件都为真，就返回true，否则就去执行onTouchEvent(event)方法并返回。
> 第一个条件：也就是说只要我们给控件注册了touch事件，mOnTouchListener就一定被赋值了
> 第二个条件：mViewFlags & ENABLED_MASK) == ENABLED是判断当前点击的控件是否是enable的，按钮默认都是enable的
> 第三个条件：mOnTouchListener.onTouch(this, event)，其实也就是去回调控件注册touch事件时的onTouch方法。也就是说如果我们在onTouch方法里返回true，就会让这三个条件全部成立，从而整个方法直接返回true。如果我们在onTouch方法里返回false，就会再去执行onTouchEvent(event)方法
> 通过以上代码，我们可以分析出onTouch方法是先于onClick方法执行的。如果以上三个条件没有同时满足，则该方法返回false，执行onTouchEvent方法，由于源码太长没有列出来。
>
> ```Java
> public void setOnClickListener(OnClickListener l) {  
>     if (!isClickable()) {  
>         setClickable(true);  
>     }  
>     mOnClickListener = l;  
> }
> ```
>
> 当我们通过调用setOnClickListener方法来给控件注册一个点击事件时，就会给mOnClickListener赋值。然后每当控件被点击时，都会在performClick()方法里回调被点击控件的onClick方法。简单的说，就是当dispatchTouchEvent在进行事件分发的时候，只有前一个action返回true，才会触发后一个action。
>
> #### onTouch和onTouchEvent有什么区别，又该如何使用？
>
> 从源码中可以看出，这两个方法都是在View的dispatchTouchEvent中调用的，onTouch优先于onTouchEvent执行。如果在onTouch方法中通过返回true将事件消费掉，onTouchEvent将不会再执行。
>
> 另外需要注意的是，onTouch能够得到执行需要两个前提条件，第一mOnTouchListener的值不能为空，第二当前点击的控件必须是enable的。因此如果你有一个控件是非enable的，那么给它注册onTouch事件将永远得不到执行。对于这一类控件，如果我们想要监听它的touch事件，就必须通过在该控件中重写onTouchEvent方法来实现
>
> ### ViewGroup
>
> ViewGroup就是一组View的集合，它包含很多的子View和子VewGroup
> 只要你触摸了任何控件，就一定会调用该控件的dispatchTouchEvent方法。这个说法没错，只不过还不完整而已。实际情况是，当你点击了某个控件，首先会去调用该控件所在布局的dispatchTouchEvent方法，然后在布局的dispatchTouchEvent方法中找到被点击的相应控件，再去调用该控件的dispatchTouchEvent方法
>
> ```Java
> public boolean onInterceptTouchEvent(MotionEvent ev) {  
>     return false;  
> }
> ```
>
> 然后dispatchTouchEvent方法
>
> ```Java
> public boolean dispatchTouchEvent(MotionEvent ev) {  
>     final int action = ev.getAction();  
>     final float xf = ev.getX();  
>     final float yf = ev.getY();  
>     final float scrolledXFloat = xf + mScrollX;  
>     final float scrolledYFloat = yf + mScrollY;  
>     final Rect frame = mTempRect;  
>     boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;  
>     if (action == MotionEvent.ACTION_DOWN) {  
>         if (mMotionTarget != null) {  
>             mMotionTarget = null;  
>         }  
>         if (disallowIntercept || !onInterceptTouchEvent(ev)) {  
>             ev.setAction(MotionEvent.ACTION_DOWN);  
>             final int scrolledXInt = (int) scrolledXFloat;  
>             final int scrolledYInt = (int) scrolledYFloat;  
>             final View[] children = mChildren;  
>             final int count = mChildrenCount;  
>             for (int i = count - 1; i >= 0; i--) {  
>                 final View child = children[i];  
>                 if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE  
>                         || child.getAnimation() != null) {  
>                     child.getHitRect(frame);  
>                     if (frame.contains(scrolledXInt, scrolledYInt)) {  
>                         final float xc = scrolledXFloat - child.mLeft;  
>                         final float yc = scrolledYFloat - child.mTop;  
>                         ev.setLocation(xc, yc);  
>                         child.mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  
>                         if (child.dispatchTouchEvent(ev))  {  
>                             mMotionTarget = child;  
>                             return true;  
>                         }  
>                     }  
>                 }  
>             }  
>         }  
>     }  
>     boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) ||  
>             (action == MotionEvent.ACTION_CANCEL);  
>     if (isUpOrCancel) {  
>         mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;  
>     }  
>     final View target = mMotionTarget;  
>     if (target == null) {  
>         ev.setLocation(xf, yf);  
>         if ((mPrivateFlags & CANCEL_NEXT_UP_EVENT) != 0) {  
>             ev.setAction(MotionEvent.ACTION_CANCEL);  
>             mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  
>         }  
>         return super.dispatchTouchEvent(ev);  
>     }  
>     if (!disallowIntercept && onInterceptTouchEvent(ev)) {  
>         final float xc = scrolledXFloat - (float) target.mLeft;  
>         final float yc = scrolledYFloat - (float) target.mTop;  
>         mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  
>         ev.setAction(MotionEvent.ACTION_CANCEL);  
>         ev.setLocation(xc, yc);  
>         if (!target.dispatchTouchEvent(ev)) {  
>         }  
>         mMotionTarget = null;  
>         return true;  
>     }  
>     if (isUpOrCancel) {  
>         mMotionTarget = null;  
>     }  
>     final float xc = scrolledXFloat - (float) target.mLeft;  
>     final float yc = scrolledYFloat - (float) target.mTop;  
>     ev.setLocation(xc, yc);  
>     if ((target.mPrivateFlags & CANCEL_NEXT_UP_EVENT) != 0) {  
>         ev.setAction(MotionEvent.ACTION_CANCEL);  
>         target.mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  
>         mMotionTarget = null;  
>     }  
>     return target.dispatchTouchEvent(ev);  
> }
> ```
>
> 方法比较长，只看重点，能看到一个for循环遍历了当前ViewGroup下的所有子View，然后在第24行判断当前遍历的View是不是正在点击的View，如果是的话就会进入到该条件判断的内部，然后在第29行调用了该View的dispatchTouchEvent
>
> ### 总结
>
> 1. Android事件分发是先传递到ViewGroup，再由ViewGroup传递到View的。
> 2. 在ViewGroup中可以通过onInterceptTouchEvent方法对事件传递进行拦截，onInterceptTouchEvent方法返回true代表不允许事件继续向子View传递，返回false代表不对事件进行拦截，默认返回false。
> 3. 子View中如果将传递的事件消费掉，ViewGroup中将无法接收到任何事件。